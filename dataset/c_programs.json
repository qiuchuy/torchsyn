[
  {
    "id": 0,
    "filename": "dataset_sample_0_20251127_010929.c",
    "inline_code": "/*\n * Generated C Neural Network Program\n * Generated by NNSmith C Backend\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <time.h>\n#include <stdbool.h>\n#include \"ops.h\"\n\n\n\n\n\n\n// Weight initialization for model\nvoid initialize_model_weights() {\n    // In practice, this would load weights from a file or initialize them\n    // Example weight initialization\n    // float conv_weight_data[] = {...};\n    // float conv_bias_data[] = {...};\n    // Load weights into the model\n    // This would be specific to your model architecture\n}\n\n\n\n\n// Input initialization for testing\nvoid initialize_test_inputs(float** input_data, const int** input_shapes, int* input_ndims) {\n\n    // Static shape arrays (could be made dynamic)\n\n    static int input_shape_0[] = {};\n\n\n\n    // Input 0: v5_0 (shape: )\n    input_shapes[0] = input_shape_0;\n    input_ndims[0] = 0;\n    input_data[0] = (float*)malloc(1 * sizeof(float));\n\n    // Initialize with random values or test data\n    for (int j = 0; j < 1; j++) {\n        input_data[0][j] = (float)rand() / RAND_MAX;  // Random [0, 1]\n    }\n\n\n}\n\n\n\n\n// Graph execution for model\n// Inline rate: 50.0%, Variants enabled: True\nvoid model_forward(float** inputs, float** outputs,\n                       const int** input_shapes, const int** output_shapes,\n                       const int* input_ndims, const int* output_ndims) {\n    // inputs[0..0]: input tensor data (raw pointers)\n    // outputs[0..1]: output tensor data (raw pointers)\n\n    // Variable declarations for intermediate tensors\n\n    float* v_0;\n    float* v_1;\n    float* v_2;\n    float* v_3;\n    float* v_4;\n    float* v_5;\n    float* v_6;\n    int v_0_shape[4];\n    int v_0_ndim;\n    int v_1_shape[4];\n    int v_1_ndim;\n    int v_2_shape[4];\n    int v_2_ndim;\n    int v_3_shape[4];\n    int v_3_ndim;\n    int v_4_shape[4];\n    int v_4_ndim;\n    int v_5_shape[4];\n    int v_5_ndim;\n    int v_6_shape[4];\n    int v_6_ndim;\n\n    // inputs[0..0]: input tensor data (raw pointers)\n    // outputs[0..1]: output tensor data (raw pointers)\n    // Shape information is passed separately\n\n\n    // Input v_0\n    v_0 = inputs[0];\n    v_0_shape[0] = 1;\n    v_0_shape[1] = 1;\n    v_0_shape[2] = 1;\n    v_0_shape[3] = 1;\n    v_0_ndim = 0;\n\n\n    // Allocate v_1 (operation: Constant)\n    v_1 = (float*)malloc(1 * sizeof(float));\n    v_1_shape[0] = 1;\n    v_1_shape[1] = 1;\n    v_1_shape[2] = 1;\n    v_1_shape[3] = 1;\n    v_1_ndim = 0;\n\n\n    // Allocate v_2 (operation: Sin)\n    v_2 = (float*)malloc(1 * sizeof(float));\n    v_2_shape[0] = 1;\n    v_2_shape[1] = 1;\n    v_2_shape[2] = 1;\n    v_2_shape[3] = 1;\n    v_2_ndim = 0;\n\n    /* INLINED */  // Sin\n    for (int _i = 0; _i < 1; _i++) { v_2[_i] = sinf(v_1[_i]); }\n\n\n    // Allocate v_3 (operation: Sub)\n    v_3 = (float*)malloc(1 * sizeof(float));\n    v_3_shape[0] = 1;\n    v_3_shape[1] = 1;\n    v_3_shape[2] = 1;\n    v_3_shape[3] = 1;\n    v_3_ndim = 0;\n\n    /* INLINED */ /* variant_v1 */ // Sub\n    { int _i; int _unroll = 1 & ~3;\n            for (_i = 0; _i < _unroll; _i += 4) {\n                v_3[_i] = v_2[_i] - v_0[_i];\n                v_3[_i+1] = v_2[_i+1] - v_0[_i+1];\n                v_3[_i+2] = v_2[_i+2] - v_0[_i+2];\n                v_3[_i+3] = v_2[_i+3] - v_0[_i+3];\n            }\n            for (; _i < 1; _i++) { v_3[_i] = v_2[_i] - v_0[_i]; }\n        }\n\n\n    // Allocate v_4 (operation: Abs)\n    v_4 = (float*)malloc(1 * sizeof(float));\n    v_4_shape[0] = 1;\n    v_4_shape[1] = 1;\n    v_4_shape[2] = 1;\n    v_4_shape[3] = 1;\n    v_4_ndim = 0;\n\n     op_abs(v_3, v_4, 1);\n\n\n    // Allocate v_5 (operation: Atan)\n    v_5 = (float*)malloc(1 * sizeof(float));\n    v_5_shape[0] = 1;\n    v_5_shape[1] = 1;\n    v_5_shape[2] = 1;\n    v_5_shape[3] = 1;\n    v_5_ndim = 0;\n\n     op_atan(v_4, v_5, 1);\n\n\n    // Allocate v_6 (operation: Neg)\n    v_6 = (float*)malloc(1 * sizeof(float));\n    v_6_shape[0] = 1;\n    v_6_shape[1] = 1;\n    v_6_shape[2] = 1;\n    v_6_shape[3] = 1;\n    v_6_ndim = 0;\n\n    /* INLINED */  // Neg\n    for (int _i = 0; _i < 1; _i++) { v_6[_i] = -v_4[_i]; }\n\n    // Copy output v1_0 to output buffer 0\n    memcpy(outputs[0], v_5, 1 * sizeof(float));\n\n    // Copy output v2_0 to output buffer 1\n    memcpy(outputs[1], v_6, 1 * sizeof(float));\n\n    // Clean up intermediate tensors (excluding input tensors)\n    if (v_1 != NULL) { free(v_1); }\n    if (v_2 != NULL) { free(v_2); }\n    if (v_3 != NULL) { free(v_3); }\n    if (v_4 != NULL) { free(v_4); }\n    if (v_5 != NULL) { free(v_5); }\n    if (v_6 != NULL) { free(v_6); }\n}\n\n// Helper function to run the complete model\nvoid run_model(float** input_data, const int** input_shapes, const int* input_ndims,\n                   float** output_data, const int** output_shapes, int* output_ndims) {\n    // Allocate output tensors\n    for (int i = 0; i < 2; i++) {\n        int output_size = compute_tensor_size(output_shapes[i], output_ndims[i]);\n        output_data[i] = allocate_tensor(output_shapes[i], output_ndims[i]);\n    }\n\n    // Run forward pass\n    model_forward(input_data, output_data, input_shapes, output_shapes, input_ndims, output_ndims);\n}\n\n\n\n\nint main() {\n    printf(\"C Neural Network Program (Raw Pointers)\\n\");\n    printf(\"======================================\\n\\n\");\n\n    // Initialize input data (using raw pointers)\n    float* input_data[1];\n    const int* input_shapes[1];\n    int input_ndims[1];\n\n    initialize_test_inputs(input_data, input_shapes, input_ndims);\n\n    // Print input information\n    printf(\"Input tensors:\\n\");\n\n    printf(\"  Input 0 (v5_0): shape=[], size=1.0\\n\");\n\n    printf(\"\\n\");\n\n    // Initialize model weights\n    initialize_model_weights();\n\n    // Prepare output storage (using raw pointers)\n    float* output_data[2];\n    static int output_shape_arrays[2][4]; // Max 4D tensors\n    const int* output_shapes[2];\n    int output_ndims[2];\n\n    // Set up output shapes\n\n    // Output 0: v1_0\n    static int output_shape_0[] = {};\n    output_shapes[0] = output_shape_0;\n    output_ndims[0] = 0;\n\n    // Output 1: v2_0\n    static int output_shape_1[] = {};\n    output_shapes[1] = output_shape_1;\n    output_ndims[1] = 0;\n\n\n    // Run the model\n    printf(\"Running model inference...\\n\");\n    clock_t start = clock();\n\n    run_model(input_data, input_shapes, input_ndims,\n              output_data, output_shapes, output_ndims);\n\n    clock_t end = clock();\n    double elapsed_time = ((double)(end - start)) / CLOCKS_PER_SEC;\n\n    printf(\"Inference completed in %.6f seconds\\n\\n\", elapsed_time);\n\n    // Print outputs\n    printf(\"Model outputs:\\n\");\n\n    printf(\"  Output 0 (v1_0, shape: ):\\n\");\n    printf(\"  [\");\n    for (int j = 0; j < 1.0; j++) {\n        printf(\"%.6f\", output_data[0][j]);\n        if (j < 1.0 - 1) printf(\", \");\n        if ((j + 1) % 8 == 0) printf(\"\\n   \");\n    }\n    printf(\"]\\n\\n\");\n\n    printf(\"  Output 1 (v2_0, shape: ):\\n\");\n    printf(\"  [\");\n    for (int j = 0; j < 1.0; j++) {\n        printf(\"%.6f\", output_data[1][j]);\n        if (j < 1.0 - 1) printf(\", \");\n        if ((j + 1) % 8 == 0) printf(\"\\n   \");\n    }\n    printf(\"]\\n\\n\");\n\n    printf(\"\\n\");\n\n    // Clean up\n    printf(\"Cleaning up memory...\\n\");\n    for (int i = 0; i < 1; i++) {\n        free(input_data[i]);\n    }\n    for (int i = 0; i < 2; i++) {\n        free(output_data[i]);\n    }\n\n    printf(\"Program completed successfully.\\n\");\n    return 0;\n}\n",
    "noinline_code": "/*\n * Generated C Neural Network Program\n * Generated by NNSmith C Backend\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <time.h>\n#include <stdbool.h>\n#include \"ops.h\"\n\n\n\n\n\n\n// Weight initialization for model\nvoid initialize_model_weights() {\n    // In practice, this would load weights from a file or initialize them\n    // Example weight initialization\n    // float conv_weight_data[] = {...};\n    // float conv_bias_data[] = {...};\n    // Load weights into the model\n    // This would be specific to your model architecture\n}\n\n\n\n\n// Input initialization for testing\nvoid initialize_test_inputs(float** input_data, const int** input_shapes, int* input_ndims) {\n\n    // Static shape arrays (could be made dynamic)\n\n    static int input_shape_0[] = {};\n\n\n\n    // Input 0: v5_0 (shape: )\n    input_shapes[0] = input_shape_0;\n    input_ndims[0] = 0;\n    input_data[0] = (float*)malloc(1 * sizeof(float));\n\n    // Initialize with random values or test data\n    for (int j = 0; j < 1; j++) {\n        input_data[0][j] = (float)rand() / RAND_MAX;  // Random [0, 1]\n    }\n\n\n}\n\n\n\n\n// Graph execution for model\n// Inline rate: 0.0%, Variants enabled: True\nvoid model_forward(float** inputs, float** outputs,\n                       const int** input_shapes, const int** output_shapes,\n                       const int* input_ndims, const int* output_ndims) {\n    // inputs[0..0]: input tensor data (raw pointers)\n    // outputs[0..1]: output tensor data (raw pointers)\n\n    // Variable declarations for intermediate tensors\n\n    float* v_0;\n    float* v_1;\n    float* v_2;\n    float* v_3;\n    float* v_4;\n    float* v_5;\n    float* v_6;\n    int v_0_shape[4];\n    int v_0_ndim;\n    int v_1_shape[4];\n    int v_1_ndim;\n    int v_2_shape[4];\n    int v_2_ndim;\n    int v_3_shape[4];\n    int v_3_ndim;\n    int v_4_shape[4];\n    int v_4_ndim;\n    int v_5_shape[4];\n    int v_5_ndim;\n    int v_6_shape[4];\n    int v_6_ndim;\n\n    // inputs[0..0]: input tensor data (raw pointers)\n    // outputs[0..1]: output tensor data (raw pointers)\n    // Shape information is passed separately\n\n\n    // Input v_0\n    v_0 = inputs[0];\n    v_0_shape[0] = 1;\n    v_0_shape[1] = 1;\n    v_0_shape[2] = 1;\n    v_0_shape[3] = 1;\n    v_0_ndim = 0;\n\n\n    // Allocate v_1 (operation: Constant)\n    v_1 = (float*)malloc(1 * sizeof(float));\n    v_1_shape[0] = 1;\n    v_1_shape[1] = 1;\n    v_1_shape[2] = 1;\n    v_1_shape[3] = 1;\n    v_1_ndim = 0;\n\n\n    // Allocate v_2 (operation: Sin)\n    v_2 = (float*)malloc(1 * sizeof(float));\n    v_2_shape[0] = 1;\n    v_2_shape[1] = 1;\n    v_2_shape[2] = 1;\n    v_2_shape[3] = 1;\n    v_2_ndim = 0;\n\n     op_sin(v_1, v_2, 1);\n\n\n    // Allocate v_3 (operation: Sub)\n    v_3 = (float*)malloc(1 * sizeof(float));\n    v_3_shape[0] = 1;\n    v_3_shape[1] = 1;\n    v_3_shape[2] = 1;\n    v_3_shape[3] = 1;\n    v_3_ndim = 0;\n\n    /* variant_v1 */ op_sub_v1(v_2, v_0, v_3, 1);\n\n\n    // Allocate v_4 (operation: Abs)\n    v_4 = (float*)malloc(1 * sizeof(float));\n    v_4_shape[0] = 1;\n    v_4_shape[1] = 1;\n    v_4_shape[2] = 1;\n    v_4_shape[3] = 1;\n    v_4_ndim = 0;\n\n     op_abs(v_3, v_4, 1);\n\n\n    // Allocate v_5 (operation: Atan)\n    v_5 = (float*)malloc(1 * sizeof(float));\n    v_5_shape[0] = 1;\n    v_5_shape[1] = 1;\n    v_5_shape[2] = 1;\n    v_5_shape[3] = 1;\n    v_5_ndim = 0;\n\n     op_atan(v_4, v_5, 1);\n\n\n    // Allocate v_6 (operation: Neg)\n    v_6 = (float*)malloc(1 * sizeof(float));\n    v_6_shape[0] = 1;\n    v_6_shape[1] = 1;\n    v_6_shape[2] = 1;\n    v_6_shape[3] = 1;\n    v_6_ndim = 0;\n\n     op_neg(v_4, v_6, 1);\n\n    // Copy output v1_0 to output buffer 0\n    memcpy(outputs[0], v_5, 1 * sizeof(float));\n\n    // Copy output v2_0 to output buffer 1\n    memcpy(outputs[1], v_6, 1 * sizeof(float));\n\n    // Clean up intermediate tensors (excluding input tensors)\n    if (v_1 != NULL) { free(v_1); }\n    if (v_2 != NULL) { free(v_2); }\n    if (v_3 != NULL) { free(v_3); }\n    if (v_4 != NULL) { free(v_4); }\n    if (v_5 != NULL) { free(v_5); }\n    if (v_6 != NULL) { free(v_6); }\n}\n\n// Helper function to run the complete model\nvoid run_model(float** input_data, const int** input_shapes, const int* input_ndims,\n                   float** output_data, const int** output_shapes, int* output_ndims) {\n    // Allocate output tensors\n    for (int i = 0; i < 2; i++) {\n        int output_size = compute_tensor_size(output_shapes[i], output_ndims[i]);\n        output_data[i] = allocate_tensor(output_shapes[i], output_ndims[i]);\n    }\n\n    // Run forward pass\n    model_forward(input_data, output_data, input_shapes, output_shapes, input_ndims, output_ndims);\n}\n\n\n\n\nint main() {\n    printf(\"C Neural Network Program (Raw Pointers)\\n\");\n    printf(\"======================================\\n\\n\");\n\n    // Initialize input data (using raw pointers)\n    float* input_data[1];\n    const int* input_shapes[1];\n    int input_ndims[1];\n\n    initialize_test_inputs(input_data, input_shapes, input_ndims);\n\n    // Print input information\n    printf(\"Input tensors:\\n\");\n\n    printf(\"  Input 0 (v5_0): shape=[], size=1.0\\n\");\n\n    printf(\"\\n\");\n\n    // Initialize model weights\n    initialize_model_weights();\n\n    // Prepare output storage (using raw pointers)\n    float* output_data[2];\n    static int output_shape_arrays[2][4]; // Max 4D tensors\n    const int* output_shapes[2];\n    int output_ndims[2];\n\n    // Set up output shapes\n\n    // Output 0: v1_0\n    static int output_shape_0[] = {};\n    output_shapes[0] = output_shape_0;\n    output_ndims[0] = 0;\n\n    // Output 1: v2_0\n    static int output_shape_1[] = {};\n    output_shapes[1] = output_shape_1;\n    output_ndims[1] = 0;\n\n\n    // Run the model\n    printf(\"Running model inference...\\n\");\n    clock_t start = clock();\n\n    run_model(input_data, input_shapes, input_ndims,\n              output_data, output_shapes, output_ndims);\n\n    clock_t end = clock();\n    double elapsed_time = ((double)(end - start)) / CLOCKS_PER_SEC;\n\n    printf(\"Inference completed in %.6f seconds\\n\\n\", elapsed_time);\n\n    // Print outputs\n    printf(\"Model outputs:\\n\");\n\n    printf(\"  Output 0 (v1_0, shape: ):\\n\");\n    printf(\"  [\");\n    for (int j = 0; j < 1.0; j++) {\n        printf(\"%.6f\", output_data[0][j]);\n        if (j < 1.0 - 1) printf(\", \");\n        if ((j + 1) % 8 == 0) printf(\"\\n   \");\n    }\n    printf(\"]\\n\\n\");\n\n    printf(\"  Output 1 (v2_0, shape: ):\\n\");\n    printf(\"  [\");\n    for (int j = 0; j < 1.0; j++) {\n        printf(\"%.6f\", output_data[1][j]);\n        if (j < 1.0 - 1) printf(\", \");\n        if ((j + 1) % 8 == 0) printf(\"\\n   \");\n    }\n    printf(\"]\\n\\n\");\n\n    printf(\"\\n\");\n\n    // Clean up\n    printf(\"Cleaning up memory...\\n\");\n    for (int i = 0; i < 1; i++) {\n        free(input_data[i]);\n    }\n    for (int i = 0; i < 2; i++) {\n        free(output_data[i]);\n    }\n\n    printf(\"Program completed successfully.\\n\");\n    return 0;\n}\n",
    "inline_lines": 294,
    "noinline_lines": 283,
    "inlined_ops_count": 3,
    "variant_count": 1,
    "line_diff": 11,
    "created_at": "2025-11-27T01:10:38.470898"
  }
]